//模块一 第二部分 ES新特性与TypeScript JS性能优化
//简答题
/**
 * 一、请说出下列最终的执行结果，并解释为什么
 * 结果：10
 * 原因：var定义的i变量存在变量提升。i变量会提升至全局执行上下文中，当循环结束时，i的值为10，当调用a[6]()函数后，打印的是全局变量i，即10
 */
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[6]() //10

/**
 * 二、请说出下列最终的执行结果，并解释为什么
 * 结果：报出引用错误，在初始化之前不能访问temp
 * 原因：块级作用域内使用了let/const关键字声明的变量，就存在暂时性死区，在声明之前使用这些变量会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭的作用域。凡在声明之前使用这些变量，就会报错
 * 虽然if语句块外面有声明temp，但语句块内部声明优先级较高
 */
// var tmp = 123;
// if (true) {
//     console.log(tmp);
//     let tmp;
// }
/**
 * 三、结合ES6新语法，用最简单的方式找出数组中的最小值
 */
var arr = [12, 34, 32, 89, 4]
console.log(Math.min(...arr))

/**
 * 四、请详细说明var let const 三种声明变量的方式之间的具体差别
 */
/**
 * 解答如下
 * 1.使用var声明变量
 * *存在变量提升、重复声明、变量污染的问题
 * *访问在后续定义的变量会返回undefined
 * *var声明的变量可以在其他作用域访问到，作用域是整个函数的
 * 2、使用let声明的变量
 * *使用let命令，会创建块级作用域
 * *let声明的变量只在块级作用域内有效，存在暂时性死区的问题
 * *同个作用域内，使用let不能重复声明变量，可以更改
 * 3、使用const声明常量
 * *使用const声明常量不能被修改
 * *使用const声明常量时需要赋值
 * *使用const声明一个引用类型数据的常量，可以往这个常量上增/删/改属性，但是不能修改这个常量的值(内存地址不能修改)
 */
/**
 * 五、请说出下列代码最终输出的结果，并解释为什么
 * 结果：20
 * 原因:setTimeout的回调是一个箭头函数，箭头函数不会改变this的指向。this始终指向沿着作用域往上找的第一个Function，看这个Function最终是怎样调用的。题目中是obj.fn(),所以此时fn内的this指向obj
 * this.a===obj.a
 */
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a);
        })
    }
}
obj.fn();
/**
 * 六、解释Symbol类型的用途
 */
/**
 * 解答：Symbol是ES2015提出的一种新的原始数据类型，主要用途有：
 * *为对象创建独一无二的key值：保证唯一性，每个Symbol值都是不相等的，这就意味着Symbol的值可以作为标识符用于对象的属性名，就可以保证不会出现同名的情况
 * *可以模拟实现对象的私有成员：定义私有属性，外部无法进行访问，只能通过类中的方法进行访问
 * *可以用作常量
 */
/**
 * 七、说说什么是深拷贝，什么是浅拷贝
 */
/**
 * 解答：引用类型的数据在赋值的过程中，其实是拷贝了内存地址，比如将b对象赋值给了a变量，这两个变量都指向了同一个内存地址，修改了a变量之后b对象也会跟着改变。
 * 我们希望得到的是，修改a不会影响b，这两个对象不会相互影响，针对这种场景就可以使用浅拷贝和深拷贝。
 * 浅拷贝是指将对象的所有属性值拷贝到新的对象，进行一层属性的拷贝，但是如果属性值也是对象的话，依旧是拷贝那个对象的地址，上面的问题还是会出现。这种情况可以使用
 * 深拷贝来解决，即使属性值是对象，深拷贝也可以做到无限层级拷贝，切断两个引用类型变量之间的关系，不会相互影响。
 * 浅拷贝：复制对象的引用，不复制对象本身。当其中一个对象属性更改时，另一个也会改变
 * 》浅拷贝的方法：遍历对象属性赋值;Object.assign();展开运算符...
 * 深拷贝:复制对象本身。当其中一个对象属性更改时，另一个不会改变
 * 》深拷贝的方法：浅拷贝+递归;JSON.parse(JSON.stringify(obj));
 * 》JSON.parse(JSON.stringify())这个方法有一定的局限性
 * *序列化时遇到如下情况需要注意：
 * *时间对象=>字符串的形式
 * *RegExp，Error=>{}
 * *会丢失function，undefined
 * *NaN，Infinity,-Infinity=>null
 * *如果对象中存在循环引用的情况也无法实现深拷贝
 * 终极深拷贝的方法可以参考lodash的深拷贝，不过日常开发如果没遇到以上的情况，采用JSON.parse(JSON.stringify())即可
 */
/**
 * 八、请简述TypeScript与JavaScript之前的关系
 */
/**
 * 解答：TypeScript是JavaScript的一个超集(扩展集)，就是在JS的基础上多出一些扩展特性，这些扩展特性包括：强大的类型系统、对ES6+的良好支持。TS最终会被编译为JS运行;
 * JavaScript是一种弱类型的脚本编程语言，无需编译，可直接在浏览器引擎和node.js环境下运行,但是TypeScript不可以,TS最终会被编译为JS运行。
 */
/**
 * 九、请谈谈你所认为的TypeScript的优缺点
 */
/**
 * 解答：
 * 优点：
 * 》使用TS新特性开发项目，项目代码的健壮性增强，代码错误更早暴露
 * 》编辑器支持情况良好：比如：VSCode,有很多智能提示,编码更准确,提升开发效率
 * 》使用TS的强类型特性来开发项目，可以使得项目代码重构更牢靠
 * 》使用TS的强类型特性来编写代码，可以减少很多不必要的类型判断
 * 》TS最终会被编译为JS运行，可以将ES6+编译为ES5/ES3,兼容性好
 * 》TS是渐进式的，完全可以使用JS编写代码,可以将新特性慢慢应用到项目中
 * 缺点：
 * 》引入了很多概念和新语法,有一定的学习成本，对于一些小项目会增加开发成本
 * 》开发过程中遇到问题，可能相关TS的网上资料比JS会少一些，需要花一些精力查找资料去解决问题
 */
/**
 * 十、描述引用计数的工作原理和优缺点
 */
/**
 * 解答：核心思想是设置引用数，判断当前引用数是否为0,引用关系改变的时候会修改引用数字，引用数字便为0立即回收
 * 优点：
 * 》发现垃圾时立即回收
 * 》最大限度减少程序暂停卡顿
 * 缺点：
 * 》空间的浪费(需要维护表来存储引用数，如果引用数过多，会带来一定的消耗)
 * 》时间开销大
 * 》无法回收循环引用的对象(即使没有被外部引用，只要引用数不为0，就无法回收资源)
 */
/**
 * 十一、描述标记整理算法的工作流程
 */
/**
 * 解答：分为三个阶段：标记、整理、清除
 * 》标记整理可看作标记清除的增强
 * 》标记阶段的操作与标记清除一致
 * 》标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象;
 * 》清除阶段：先执行整理，将对象的地址进行移动，使其在地址上连续；collector对堆内存(header memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象(通过读取对象的header信息)，清除未标记对象
 * 》最后回收相应的空间
 */
/**
 * 十二、描述V8中新生代存储区垃圾回收的流程
 */
/**
 * 解答：新生代存储区垃圾回收流程
 * 》回收过程采用复制算法+标记整理
 * 》新生代内存区分为两个等大小空间From和To
 * 》使用空间为From，空闲空间为To
 * 》活动对象(可达对象)存储在From空间,标记整理后将活动对象拷贝至To
 * 》拷贝过程中可能出现晋升(晋升就是将新生代对象移动至老生代)
 * 》一轮GC还存活的新生代需要晋升;To空间使用率超过25%,也要将活动对象移动至老生代
 * 》最后将From与To交换空间完成内存释放
 */
/**
 * 十三、描述增量标记算法在何时使用及工作原理
 */
/**
 * 解答：
 * 增量标记算法：将一整段的垃圾回收操作，拆分成多个小步，组合完成整个垃圾回收操作。我们知道，当垃圾回收工作的时候，会阻塞JS程序执行，当我们需要优化垃圾回收的效率时，就可以使用增量标记算法
 * 优点:让垃圾回收和程序执行可以交替完成，让时间消耗更合理，达到效率优化的好处
 * 工作原理：
 * 》JS程序执行的过程中，会伴随着垃圾回收的工作
 * 》当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，此时停下标记操作
 * 》然后让JS程序执行一会儿，之后再让GC机制去做二步的标记操作，去标记那些间接可达的对象
 * 》重复以上两步，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
 * 》直到标记操作完成之后，最后执行垃圾回收
 */